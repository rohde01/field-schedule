import { z } from 'zod';
import { constraintSchema } from './constraint';

export const scheduleEntrySchema = z.object({
    schedule_entry_id: z.number().int().positive(), // Database primary key for this specific entry. Generated by the database.
    schedule_id: z.number().int().positive().nullable().optional(), // Foreign key linking this entry to a parent 'schedules' container.
    team_id: z.number().int().positive().nullable().optional(),
    field_id: z.number().int().positive().nullable().optional(),

    dtstart: z.coerce.date({ // The start date and time of this specific event instance or the first instance in a recurring series. Required.
      errorMap: () => ({ message: "dtstart must be a valid date/time string" }),
    }),
    dtend: z.coerce.date({ // The end date and time of this specific event instance or the first instance in a recurring series. Must be after dtstart. Required.
      errorMap: () => ({ message: "dtend must be a valid date/time string" }),
    }),
    recurrence_rule: z.string().nullable().optional(), // An RFC 5545 recurrence rule string (e.g., 'FREQ=WEEKLY;BYWEEKDAY=MO;UNTIL=...') defining how this event repeats. Null for standalone events or exception entries.
    
    // If this entry represents an exception (modification/override) to a recurring series, this field holds the ORIGINAL start timestamp of the instance being overridden. Null otherwise.
    recurrence_id: z.coerce.date({ 
        errorMap: () => ({ message: "recurrence_id must be a valid date/time string" }),
      }).nullable().optional(),
  

    recurring_entry_id: z.number().int().positive().nullable().optional(), // If this entry is an exception (recurrence_id is not null), this links back to the schedule_entry_id of the master recurring event definition (the one with the recurrence_rule). Null otherwise.
  
    // An array of specific original start dates/times that should be excluded (cancelled) from the recurrence rule defined in the master entry. Used only on master entries (where recurrence_rule is not null).
    exdate: z.array(z.coerce.date({
        errorMap: () => ({ message: "Each exdate must be a valid date/time string" }),
      })).nullable().optional(),
  
    summary: z.string().max(255).nullable().optional(), // A short, user-visible title or summary for the event (e.g., "U12 Practice").
    description: z.string().nullable().optional(), // A longer, user-visible description or notes field for the event.
  
  }).refine(data => data.dtend > data.dtstart, {
    message: "dtend must be after dtstart",
    path: ["dtend"], // Point error to the dtend field
  });
  

export const scheduleSchema = z.object({
    schedule_id: z.number().int(),
    club_id: z.number().int().positive(),
    name: z.string().min(1),
    facility_id: z.number().int().positive(),
    schedule_entries: z.array(scheduleEntrySchema),
    active_from: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, {
        message: "active_from must be in the format YYYY-MM-DD"
      }),
    active_until: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, {
        message: "active_until must be in the format YYYY-MM-DD"
      }),
});

export type ScheduleEntry = z.infer<typeof scheduleEntrySchema>;
export type Schedule = z.infer<typeof scheduleSchema>;

export const generateScheduleRequestSchema = z.object({
    facility_id: z.number().int().positive(),
    team_ids: z.array(z.number().int().positive()).min(1, {
        message: "You must tick off at least one team from the sidebar to go in the schedule"
    }),
    constraints: z.array(constraintSchema).optional(),
    club_id: z.number().int().positive(),
    schedule_name: z.string()
});

export const deleteScheduleSchema = z.object({
    schedule_id: z.number().int().positive()
});

export type DeleteScheduleResponse = {
    message: string;
    action: string;
};

export type GenerateScheduleRequest = z.infer<typeof generateScheduleRequestSchema>;

export const activeScheduleCreateSchema = z.object({
    club_id: z.number(),
    schedule_id: z.number(),
    start_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
    end_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/)  
});

export const activeScheduleUpdateSchema = z.object({
    schedule_id: z.number(),
    start_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
    end_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) 
});

export type ActiveSchedule = {
    active_schedule_id: number;
    schedule_id: number;
    start_date: string;
    end_date: string;
    is_active?: boolean;
};

export type CalendarDate = {
    date: Date;
    weekDay: number;
    formattedDate: string;
    isWithinActiveSchedule: boolean;
    activeScheduleId?: number;
};

export type ActiveScheduleCreate = z.infer<typeof activeScheduleCreateSchema>;
export type ActiveScheduleUpdate = z.infer<typeof activeScheduleUpdateSchema>;
